/*
 * Copyright 2016 Google.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.genomics.dockerflow.args;

import com.google.cloud.genomics.dockerflow.task.TaskDefn.Resources;
import com.google.cloud.genomics.dockerflow.util.StringUtils;
import com.google.cloud.genomics.dockerflow.workflow.WorkflowFactory;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A replacement for the autogenerated Pipelines API's RunPipelineArgs object. Reason: it works with
 * standard json serializers.
 */
@SuppressWarnings("serial")
public class TaskArgs implements Serializable {
  private static final Logger LOG = LoggerFactory.getLogger(TaskArgs.class);

  private String projectId;
  private String clientId;
  private Map<String, String> inputs;
  private Set<String> fromFile; // input values come from loading a file
  private Map<String, String> outputs;
  private Logging logging;
  private Resources resources;
  private ServiceAccount serviceAccount;
  private String keepVmAliveOnFailureDuration;

  public TaskArgs() {}

  /** Copy constructor. */
  public TaskArgs(TaskArgs args) {
    if (args != null) {
      projectId = args.projectId;
      clientId = args.clientId;
      if (args.getInputs() != null) {
        inputs = new LinkedHashMap<String, String>(args.inputs);
      }
      if (args.getOutputs() != null) {
        outputs = new LinkedHashMap<String, String>(args.outputs);
      }
      if (args.logging != null) {
        logging = new Logging(args.logging);
      }
      if (args.resources != null) {
        resources = new Resources(args.resources);
      }
      if (args.serviceAccount != null) {
        serviceAccount = new ServiceAccount(args.serviceAccount);
      }
      if (args.getFromFile() != null) {
        setFromFile(new HashSet<String>(args.getFromFile()));
      }
      if (args.keepVmAliveOnFailureDuration != null) {
        keepVmAliveOnFailureDuration = args.keepVmAliveOnFailureDuration;
      }
    }
  }

  /**
   * Substitute global variables of the form ${KEY} in all inputs, outputs, and logging paths.
   *
   * @param globals KEY/VALUE pairs
   */
  public void substitute(Map<String, String> globals) {

    // Substitute in the logging path
    if (logging != null && logging.getGcsPath() != null) {
      logging.setGcsPath(StringUtils.replaceAll(globals, logging.getGcsPath()));
    }

    // Substitute in inputs
    if (inputs != null) {
      for (String key : inputs.keySet()) {
        String val = inputs.get(key);
        val = StringUtils.replaceAll(globals, val);
        inputs.put(key, val);
      }
    }

    // Substitute in outputs
    if (outputs != null) {
      for (String key : outputs.keySet()) {
        String val = outputs.get(key);
        val = StringUtils.replaceAll(globals, val);
        outputs.put(key, val);
      }
    }

    // Substitute in resource sizes
    if (resources != null) {
      resources.applyGlobals(globals);
    }
  }

  /**
   * Apply args (e.g., from the command-line) to this task. The project id logging path, and
   * resource settings will be applied.
   *
   * @param a override with these arguments
   */
  public void applyArgs(TaskArgs a) {
    if (a.getProjectId() != null) {
      projectId = a.getProjectId();
    }

    // Set logging path
    if (a.getLogging() != null && a.getLogging().getGcsPath() != null) {
      if (logging == null) {
        logging = new Logging();
      }
      logging.setGcsPath(a.getLogging().getGcsPath());
    }

    // Set resource settings
    if (a.getResources() != null) {
      if (resources == null) {
        resources = new Resources();
      }
      if (a.getResources().getZones() == null) {
        resources.setZones(new ArrayList<String>());
      } else {
        resources.setZones(
            WorkflowFactory.expandZones(
                a.getResources()
                    .getZones()
                    .toArray(new String[a.getResources().getZones().size()])));
      }
      resources.setPreemptible(a.getResources().getPreemptible());
      resources.setMinimumCpuCores(a.getResources().getMinimumCpuCores());
      resources.setMinimumRamGb(a.getResources().getMinimumRamGb());
    }
    if (a.getKeepVmAliveOnFailureDuration() != null) {
      keepVmAliveOnFailureDuration = a.getKeepVmAliveOnFailureDuration();
    }
  }

  /**
   * For run instance args, merge the default workflow args.
   *
   * @param defaultArgs the default workflow args
   */
  public void mergeDefaultArgs(TaskArgs defaultArgs) {
    WorkflowArgs defaults = new WorkflowArgs(defaultArgs);

    if (defaults.getInputs() != null) {
      LinkedHashMap<String, String> mergedInputs = new LinkedHashMap<String, String>();
      
      // Defaults come first
      if (defaults.getInputs() != null) {
        mergedInputs.putAll(defaults.getInputs());
      }
      // Then override
      if (inputs != null) {
        mergedInputs.putAll(inputs);
      }
      Map<String, String> old = inputs;
      inputs = mergedInputs;
      
      // Do variable substitution of the defaults
      substitute(old);
    }
    if (defaults.getOutputs() != null) {
      LinkedHashMap<String, String> mergedOutputs = new LinkedHashMap<String, String>();
      
      // Defaults come first
      if (defaults.getOutputs() != null) {
        mergedOutputs.putAll(defaults.getOutputs());
      }
      // Then override
      if (outputs != null) {
        mergedOutputs.putAll(outputs);
      }
      Map<String, String> old = outputs;
      outputs = mergedOutputs;
      
      // Do variable substitution of the defaults
      substitute(old);
    }
    if (defaults.getFromFile() != null) {
      if (getFromFile() != null) {
        defaults.getFromFile().addAll(getFromFile());
      }
      setFromFile(defaults.getFromFile());
    }
    if (logging == null || logging.gcsPath == null) {
      logging = defaults.getLogging();
    }
    if (projectId == null) {
      projectId = defaults.getProjectId();
    }
    if (clientId == null) {
      clientId = defaults.getClientId();
    }
    if (serviceAccount == null) {
      serviceAccount = defaults.getServiceAccount();
    }
    if (keepVmAliveOnFailureDuration == null) {
      keepVmAliveOnFailureDuration = defaults.getKeepVmAliveOnFailureDuration();
    }

    if (resources == null) {
      resources = defaults.getResources();
    } else if (defaults.getResources() != null) {
      if (defaults.getResources().getPreemptible() != null) {
        resources.setPreemptible(defaults.getResources().getPreemptible());
      }
      if (defaults.getResources().getZones() != null && !defaults.getResources().getZones().isEmpty()) {
        resources.setZones(defaults.getResources().getZones());
      }
      if (defaults.getResources().getDisks() != null && !defaults.getResources().getDisks().isEmpty()) {
        resources.setDisks(defaults.getResources().getDisks());
      }
      if (defaults.getResources().getMinimumCpuCores() != null) {
        resources.setMinimumCpuCores(defaults.getResources().getMinimumCpuCores());
      }
      if (defaults.getResources().getMinimumRamGb() != null) {
        resources.setMinimumRamGb(defaults.getResources().getMinimumRamGb());
      }
    }
  }

  /** Gather task args into this, for scatter-gather and for merging branches in a workflow. */
  public void gatherArgs(TaskArgs ta) {
    for (String param : ta.keys()) {

      // Add an arg that doesn't exist in all shards
      if (!contains(param)) {
        LOG.info("Adding missing arg: " + param + " with value: " + ta.get(param));
        set(param, ta.get(param));
      }
      // Concatenate values of the same arg in order
      else if (!get(param).equals(ta.get(param))) {
        LOG.info("Combining args: " + param + " with value: " + ta.get(param));
        set(param, get(param) + "\n" + ta.get(param));
      }
    }
  }

  public String getProjectId() {
    return projectId;
  }

  public void setProjectId(String projectId) {
    this.projectId = projectId;
  }

  public String getClientId() {
    return clientId;
  }

  public void setClientId(String clientId) {
    this.clientId = clientId;
  }

  public Map<String, String> getInputs() {
    return inputs;
  }

  /** The input or output value matching the key. */
  public String get(String key) {
    String val = null;
    if (inputs != null && inputs.containsKey(key)) {
      val = inputs.get(key);
    } else if (outputs != null && outputs.containsKey(key)) {
      val = outputs.get(key);
    }
    return val;
  }

  public boolean contains(String key) {
    return (inputs != null && inputs.containsKey(key))
        || (outputs != null && outputs.containsKey(key));
  }

  /** Non-null, possibly empty set of all input and output parameter names. */
  public Set<String> keys() {
    Set<String> s = new HashSet<String>();
    if (inputs != null) {
      s.addAll(inputs.keySet());
    }
    if (outputs != null) {
      s.addAll(outputs.keySet());
    }
    return s;
  }

  /**
   * Set the input or output value matching the key. If neither matches, create a new input
   * key/value pair.
   */
  public void set(String key, String value) {
    if (inputs != null && inputs.containsKey(key)) {
      inputs.put(key, value);
    } else if (outputs != null && outputs.containsKey(key)) {
      outputs.put(key, value);
    } else {
      if (inputs == null) {
        inputs = new LinkedHashMap<String, String>();
      }
      inputs.put(key, value);
    }
  }

  /** Load the variable value from file. */
  public void setFromFile(String key, boolean isFromFile) {
    if (isFromFile) {
      if (fromFile == null) {
        fromFile = new HashSet<String>();
      }
      fromFile.add(key);
    } else if (fromFile != null) {
      fromFile.remove(key);
    }
  }

  public boolean isFromFile(String key) {
    return getFromFile() != null && getFromFile().contains(key);
  }

  public void setInputs(Map<String, String> inputs) {
    this.inputs = new LinkedHashMap<String, String>(inputs);
  }

  public Map<String, String> getOutputs() {
    return outputs;
  }

  public void setOutputs(Map<String, String> outputs) {
    this.outputs = new LinkedHashMap<String, String>(outputs);
  }

  public Logging getLogging() {
    return logging;
  }

  public void setLogging(Logging logging) {
    this.logging = logging;
  }

  public Resources getResources() {
    return resources;
  }

  public void setResources(Resources resources) {
    this.resources = resources;
  }

  public ServiceAccount getServiceAccount() {
    return serviceAccount;
  }

  public void setServiceAccount(ServiceAccount serviceAccount) {
    this.serviceAccount = serviceAccount;
  }

  public String getKeepVmAliveOnFailureDuration() {
    return keepVmAliveOnFailureDuration;
  }

  public void setKeepVmAliveOnFailureDuration(String keepVmAliveOnFailureDuration) {
    this.keepVmAliveOnFailureDuration = keepVmAliveOnFailureDuration;
  }

  public Set<String> getFromFile() {
    return fromFile;
  }

  public void setFromFile(Set<String> fromFile) {
    this.fromFile = fromFile;
  }

  public static class Logging implements Serializable {
    private String gcsPath;

    public Logging(Logging logging) {
      gcsPath = logging.gcsPath;
    }

    public Logging() {}

    public String getGcsPath() {
      return gcsPath;
    }

    public void setGcsPath(String gcsPath) {
      this.gcsPath = gcsPath;
    }
  }

  public static class ServiceAccount implements Serializable {
    private String email;
    private List<String> scopes;

    public ServiceAccount(ServiceAccount serviceAccount) {
      email = serviceAccount.email;
      if (serviceAccount.getScopes() != null) {
        scopes = new ArrayList<String>(serviceAccount.getScopes());
      }
    }

    public ServiceAccount() {}

    public String getEmail() {
      return email;
    }

    public void setEmail(String email) {
      this.email = email;
    }

    public List<String> getScopes() {
      return scopes;
    }

    public void setScopes(List<String> scopes) {
      this.scopes = scopes;
    }
  }
}
